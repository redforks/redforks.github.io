<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Forks 的代码工坊</title>
    <link>http://sample.com</link>
    <pubDate>14 Nov 16 00:08 CST</pubDate>
    <item>
      <title>Open Close Loop</title>
      <link>http://sample.com/default/Open-Close-Loop/</link>
      <pubDate>2016-11-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;开环闭环与组织机构&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;我有一些控制系统开发的经验，不自觉的用控制系统的角度来思考组织机构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;组织是因为一个特定的目的创建的。只要是多人合作的工作就需要组织。控制系统也一样：为了特定的目的，简单的如调节温度，复杂的如大型自动化工厂，需要把硬件设备组织在一起。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;控制系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;控制系统设计，一个非常重要的考虑因素是，开环还是闭环？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所谓开环，就是完全不理会反馈，按照既定计划执行。很多机械化的装置都属于这种。以多米诺骨牌为例，多米诺骨牌的目的：建立一个系统，使远端的骨牌倒下。多米诺的解决方式是推倒第一块，依次推倒下一块，直到最后一块倒下，问题解决。在执行过程中（倒下过程中），完全不考虑意外因素，骨牌高度，距离，地势，甚至风力。出现一次意外，只有失败。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所谓开环，是在执行过程中，监视执行情况，对变化采取应对措施。比如空调，温度高了启动压缩机，低了关闭压缩机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开环的好处显而易见，系统更柔性，失败率更低。实际的控制系统中多多少少都会引入一些反馈，引入反馈越多不越好吗？这个问题像何不食肉糜一样可笑。不是因为不想而是因为不可得。我总结影响反馈的主要是两个因素：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;误差。从反馈系统得到的信息，和真实情况不是百分百一样的。如果误差过大，以错误值做调整依据，只会更乱。&lt;/li&gt;&#xA;&lt;li&gt;时效性。时效性分为两方面：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;获取信息并传递到控制机构的时间。如果传递速度太慢，或者目标对象变化太快，得到的是历史数据，不能反应当前情况。&lt;/li&gt;&#xA;&lt;li&gt;执行速度和力度。执行机构动作迟缓，或者力度不够，等执行效果起作用，目标对象早已发生变化。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;错误的引入反馈，常见的现象就是震荡，严重时震荡逐渐放大，系统崩溃。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;组织机构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;开环，闭环对应在组织机构里是专治和民主。为什么要开环，不采用闭环？其原因也和控制系统类似：反馈的误差和时效。要达到有效的民主，必须建立高效，低误差的反馈渠道，和高效率的执行机构，否则就陷入混乱。这同时需要软件（人）和硬件（科技）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人类历史无疑是专治占据主要时间，因为技术的不成熟。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;没有有效的保存信息的手段，文字，手绘无法准确表达真实情况。直到照相，录音，摄像等设备的发明。所谓一图胜万言。文学作品想象空间巨大，其实说得是误差巨大。&lt;/li&gt;&#xA;&lt;li&gt;没有高效的信息传递手段，烽火台速度尚可，但带宽不够，无法传递大量信息（其实只能有效传递是否两种状态）。驿站和快马数据量够了但速度太慢。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在这种情况下，能够成功运转的组织，只有专治一途。古希腊是罕见的按照民主方式成功运转的，因为古希腊是城邦国家，组织的规模不大，地域不广，信息的采集和反馈执行都不是瓶颈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与专治相配合，产生了相应的文化。我认为这类文化的特点是：重执行，轻思考；重精神，轻物质。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在无法及时或有效的处理反馈的情况下，最成功的方法是严格按照计划执行。二战时日本在太平洋战场上，面对美军的优势火力，仍然一次次的冲锋。这种愚蠢的行为，是他们重执行，轻反馈的体现。他们无法应对变化，是因为他们的系统是建立在僵化和执行的基础上。高层决定目标，智囊制定计划，大众全力执行。完美的开环设计，智囊不能质疑高层的决定，不可为而为之，大众只管执行，无法获得足够的信息。培养人们的思考意识，信息平等会给整个体系带来干扰，危及社会架构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以观察，如果一个企业过多的强调执行力，多半是专治的僵化的，无法适应市场变化的，依赖一时的高利润，垄断，社会绑架而存在的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个企业通过垄断，固化市场，通过控制环境来消除干扰（变化），实现有效的开环控制。但这种僵化的结构，柔性不足，在应对变化前缺乏弹性。容易如生铁般瞬间折断。中国历史，也就是朝代更替的历史。历朝历代都努力通过社会僵化的方法来努力延续，但社会变化的速度最终会超过维持僵化的努力，断裂不可避免。企业也是一样，人事震荡，甚至一夜倒闭都时有耳闻。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Oral vs Written</title>
      <link>http://sample.com/default/Oral-vs-Written/</link>
      <pubDate>2016-11-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;口头语与书面语&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;写文章和说话有很多不同，我体会到的有几方面，分别说一说。写和说都不是我的特长，只是说说我的体会罢了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;冗余&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这个区别是媒介导致的，口头语是语音，书面语是纸张。语音在传输上不大可靠，说话者的口齿是否清楚，方言俚语，听者的听力，理解能力，传输距离都是不利因素。一如通讯技术中的解决方法，加入冗余，降低信息密度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语往往啰嗦，目的是增加冗余。听者个别字词没有听清，不影响意思的表达。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语往往增加无意义的字词，“这个”，“那个”，“嗯啊”，目的是降低对听者大脑处理速度的要求。讲课，新闻等复杂的内容，对听者理解力的要求很高，降低语速和插入无意义的字词是非常必要的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;书面语正相反，有了可靠的媒介，冗余不需要的。要求写作时避免重复。增一分则胖，减一分则瘦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阅读也速度要求，没有冗余，增高的信息密度，不会给阅读带来困难。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;上下文&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;上下文对意思的理解非常重要。表达意思的不是文字和语言，是建立在共同的理解上的。如果给没有笑的功能的外星人看“笑”字，他是无法理解的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人人都能理解的，首先是五感，触觉，味觉，视觉，听觉，体感。我们用“甜蜜”表示很多非食物的东西，因为我们都能理解“甜蜜”是什么。其次是血缘关系，父母，兄弟，子孙。我们常常把受尊敬的人和物比作母亲，把平等的人比作兄弟等。再把血缘关系映射到社会结构，“家” - &amp;ldquo;国&amp;rdquo;；“父” - “君”；“子” - “臣”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然”甜蜜“可以指食物，也可以指关系，那么如何才能不混淆呢？这就需要上下文。如果话题是食物，自然是食物，话题是爱人，自然是人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语上下文的建立是自然的，常常不是通过语言。餐桌上，瀑布边，会议室，对话对象，都能自然的创建双方的上下文。如果听者不集中注意力，没有建立好上下文，就难以理解对话，把“撒谎“听成”上床“。或者没有共同的经历，也不容易建立上下文。秀才遇见兵，有理说不清。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;书面语要建立上下文，困难多，它的手段只有文字，偶尔借助图片。我们常常看到新闻，小说，以图片开头，也是这个道理。引子，序的作用也是如此。抛出一个问题，电影开头搞一个爆炸，说书艺人的开场白都是这个目的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为上下文的薄弱，用词准确对书面语有了更高的要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阅读，已经从卖方市场变为买方市场。论语不用在乎读者，读懂论语是读者的责任。而如今，如何让文章让人更容易理解变得更重要。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;叙述主体&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这个问题在口头语中是不存在的，几乎都是“我”。所以不用强调，听者听着也自然。但在书面语上，这是个复杂的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在开始阅读前，叙述主体对读者来说是未知的。读者需要一个识别的过程。写作者需要选择一个适合读者理解的叙述主体，帮助读者建立叙述主体，并坚持始终。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Life Package</title>
      <link>http://sample.com/default/Life-Package/</link>
      <pubDate>2016-11-06 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Life golang package&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Life 是一个 Go 语言的 包(Package) 管理库：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Package 按照依赖顺序启动&lt;/li&gt;&#xA;&lt;li&gt;按照依赖的反序停止&lt;/li&gt;&#xA;&lt;li&gt;钩子函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;详细说明请看：&lt;a href=&#34;http://github.com/redforks/life&#34;&gt;http://github.com/redforks/life&lt;/a&gt; 的 README.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Spriter - 自动生成 css sprite</title>
      <link>http://sample.com/default/Spriter---%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90-css-sprite/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;又一个css sprite工具？是的，她存在的理由是&lt;strong&gt;自动&lt;/strong&gt;。以一个例子来说明，假如有如下css：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(&#39;grp1.object.png&#39;);&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(&#39;grp1.method.png&#39;);&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(&#39;grp1.form.png&#39;);&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(&#39;grp2.list.png&#39;);&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(&#39;grp2.template.png&#39;);&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(&#39;grp2.enum.png&#39;);&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(&#39;grp2.service.png&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;每一个图标，都是单独的图标文件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.object.png&#34; alt=&#34;object&#34; /&gt;:  grp1.object.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.method.png&#34; alt=&#34;method&#34; /&gt;:  grp1.method.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.form.png&#34; alt=&#34;form&#34; /&gt;: grp1.form.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.list.png&#34; alt=&#34;list&#34; /&gt;:  grp2.list.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.template.png&#34; alt=&#34;template&#34; /&gt;:  grp2.template.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.enum.png&#34; alt=&#34;enum&#34; /&gt;: grp2.enum.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.service.png&#34; alt=&#34;service&#34; /&gt;: grp2.service.png&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;运行&lt;code&gt;Spriter&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;spriter -i tree.css -o build/tree.css&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成三个文件：&lt;code&gt;tree.css&lt;/code&gt;, &lt;code&gt;Q-EoXMh-.png&lt;/code&gt;, &lt;code&gt;GyO8rqsS.png&lt;/code&gt;。tree.css的内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(Q-EoXMh-.png) no-repeat;&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(Q-EoXMh-.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(Q-EoXMh-.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(GyO8rqsS.png) no-repeat;&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(GyO8rqsS.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(GyO8rqsS.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(GyO8rqsS.png) no-repeat -48px 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q-EoXMh-.png: &lt;img src=&#34;/assets/media/Q-EoXMh-.png&#34; alt=&#34;Compiled spriter 1&#34; /&gt;, GyO8rqsS.png: &lt;img src=&#34;/assets/media/GyO8rqsS.png&#34; alt=&#34;Compiled spriter 2&#34; /&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 寻找 background 图片，如果符合 &lt;code&gt;group.name.png&lt;/code&gt;格式，按&lt;code&gt;group&lt;/code&gt;名来分组，每组生成一个 sprite ，如这里的 &lt;code&gt;grp1&lt;/code&gt; 和 &lt;code&gt;grp2&lt;/code&gt; 两组。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对生成的 sprite 图片文件，计算 hash value, 用其前缀作为文件名。sprite 任何变化文件名也会相应改变&lt;a name=&#34;footnote1&#34;&gt;¹&lt;/a&gt;。当增加或减少了同组文件的数量，或者修改了图片，则 sprite 文件名也会改变。对 sprite 文件可以安全的打开 http cache，并设置有效期为一万年（开个玩笑，习惯上设置为一年）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件名使用 &lt;code&gt;URL&lt;/code&gt; 安全的 &lt;code&gt;base64&lt;/code&gt; 编码，普通的 &lt;code&gt;base64&lt;/code&gt; 符号集有时会制造麻烦，毕竟图片文件也是用 http URL访问的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt; 语言，最简单的安装方式是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/redforks/css/cmd/spriter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 和 &lt;code&gt;OS/X&lt;/code&gt; 中都能正常运行，理论上 &lt;code&gt;Windows&lt;/code&gt; 也可以，不过没有试过。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;总结&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;优势和特点&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无须手工制作 sprite 文件&lt;/li&gt;&#xA;&lt;li&gt;无须手工维护 sprite image 的 位移 offset&lt;/li&gt;&#xA;&lt;li&gt;开发过程中，直接使用源图片，不要担心 sprite&lt;/li&gt;&#xA;&lt;li&gt;配合 &lt;code&gt;css&lt;/code&gt; 编译工具，把多个 css 文件合并后，运行 &lt;code&gt;Spriter&lt;/code&gt;，保证 sprite 里只有被使用的图像，没有任何带宽浪费。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;任何问题， fire issue at &lt;a href=&#34;http://github.com/redforks/css&#34;&gt;http://github.com/redforks/css&lt;/a&gt; or email: &lt;a href=&#34;mailto:redforks@gmail.com&#34;&gt;redforks@gmail.com&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;#footnote1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 理论上存在着两个不同的文件，拥有相同的 hash value，特别是这里只使用了 hash value 的前缀。但实际上几乎几乎不会发生。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>名字生成器</title>
      <link>http://sample.com/default/%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;软件，特别是企业软件在测试，演示时，需要填充大量的数据。如果使用人工输入，显然效率太低，而机器生成随机字符串，又效果欠佳。这就是名字生成器的作用：生成&lt;strong&gt;随机的看上去有意义&lt;/strong&gt;的名字。目前支持四种名字：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/name?n=100&#34;&gt;人名&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/product?n=100&#34;&gt;产品&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/firm?n=100&#34;&gt;公司&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/address?n=100&#34;&gt;地址&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每一个生成器以原始样本为素材，生成随机的名字。原始样本的数量：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;生成器&lt;/th&gt;&#xA;&lt;th&gt;原始样本数量&lt;sub&gt;(写这篇博文时)&lt;/sub&gt;&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;人名&lt;/td&gt;&#xA;&lt;td&gt;12715&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;产品&lt;/td&gt;&#xA;&lt;td&gt;473347&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;公司&lt;/td&gt;&#xA;&lt;td&gt;32893&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;地址&lt;/td&gt;&#xA;&lt;td&gt;31029&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;生成器接受&lt;strong&gt;n&lt;/strong&gt;参数，控制生成的名字数量。比如：&lt;a href=&#34;http://127.0.0.1:8080/names/address?n=10&#34;&gt;http://127.0.0.1:8080/names/address?n=10&lt;/a&gt;生成10个地址。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;返回纯文本，utf8编码，名字间用回车分隔。非常方便机器调用，各种编程语言都很容易访问。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;相关技术&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;马可夫链(Markov chain)&lt;/li&gt;&#xA;&lt;li&gt;正态分布&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/redforks/math/blob/master/random/weighted_choice.go&#34;&gt;Weighted random choice&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;golang&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>