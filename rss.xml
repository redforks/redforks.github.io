<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Forks 的代码工坊</title>
    <link>http://sample.com</link>
    <pubDate>14 Jul 17 09:04 CST</pubDate>
    <item>
      <title>Mr. Xia&#39;s Beard</title>
      <link>http://sample.com/default/Mr.-Xia%27s-Beard/</link>
      <pubDate>2017-07-14 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;夏老师的胡子&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;夜里做了个梦，有些复杂不想失去，把它记录下来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;话说因为一个特殊的原因，我们一家着急的赶回了矿大，去找胡老师。胡老师在上课。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是一堂很重要很有意义的课：《再见FoxBase》，是告别FoxBase时代的一堂课，是胡老师告别副教授，晋升正教授的评定课。讲台后面坐着院系领导，和分管教学的校领导，主席台般坐着,面对着同学们。教室最后面听课的是院里的老师。中间的同学是所有计93的同学，也是现在的年龄。高老师也在，这么重要的时刻不能缺了高老师。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同学们把珍藏了多年的 FoxBase 课本都带来了，准备着最后一课之后的伟大仪式--撕书。课前大家纷纷在书上留言。我记得夏阳老师写的是：“前后都一样”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开始讲课了。胡老师先介绍 FoxBase 出现的历史背景，以及必要性，然后介绍 FoxBase 的特殊语法结构。FoxBase 的基本程序结构是页（Page），如果页中只有一条语句，则这条语句自动重复，占据整个页；如果没有一条语句，则使用默认语句占据整个页（默认语句是什么，梦里没有说，估计我构建不出来，什么语句能默认到覆盖大部分情况？）。大家于是感叹，新语言太复杂了，没有 FoxBase 经典，完美。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里打断一下梦，现在想来，这个特殊的语法设计，也许是为了解决夏老师的感悟：夏老师1百多行的程序，别的老师需要1千多行。因为别的老师在需要用循环的的时候，手工重复。这样想起来， FoxBase 的智能重复真的有它的道理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我上课有个不好的习惯：观察。观察老师，观察同学，观察窗外&amp;hellip; 我观察到夏老师今天的胡子很酷，胡子艺术般的长度，约10～15厘米，两边短些，中间长些。按照夏老师的标准，这不能算酷。奇妙处在于：胡子中间是镂空的。胡子一根根垂直平行，两端和中间共有3根胡子和脸颊连接，其余的胡子都断开，镂空部分构成一个图案。见图，梦里的图案艺术多了，我画不出，有点像旧时小姐的屏风或者窗棂）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/MrXiaBeard.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我开始琢磨夏老师“前后都一样”的含义，FoxBase可不是前后都一样吗，第一行自动重复到最后。忽然就顿悟了：人生学习，体验到最后，领悟到的只有哲学。学这门，那门课，不同的职业，不同的经历，留下的一点点感悟，一点点的体验，都是属于自己的哲学。但哲学界断言：不管你悟到的是哪种哲学，都被某个哲学家曾经阐述过。与其花一辈子去感悟，不如在大学里，提前学习了哲学。节约大量的思考时间，顿悟起来也更完备和圆满。前后都一样，前后也不一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是梦中和醒之后的顿悟：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;哲学和数学一样不是一门科学，而是工具学。和尺子，圆规一样，是丈量描述世界和我（或者我和世界，颠倒一下哲学意义可不同）的工具。问题是没有银弹，没有Universal的工具。非欧几何荒谬，但能解决欧式几何无法解决的问题。高中政治记得最清楚的一句话是：“哲学家们只是用不同的方式解释世界，而问题在于改变世界。”马克思这句话的理解，我一直认为不同的哲学家是使用不同的坐标系来描述，度量，既然如此，不同的哲学家尺子不同罢了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人认识世界的方法在于抽象，努力找出放之四海都适用的规律。以至于 Believed ，坚定的人们相信他掌握的规律比自然更可靠，做出种种匪夷所思之举。但世界和人们认识到的世界是不同的，世界就是世界，我就是我。世界是空，我们看到的色形成了相，也就是人的认识。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以把人抽象为某些特质：勇敢，聪明，忠诚，但这等于这个人吗？我想真正熟悉他的人甚至抽象不出这些特质来。最伟大的大师，往往都没有留下著作。孔子，释迦牟尼，耶稣，都是由他们的门人和弟子总结出来的。他们和道是一体的，他们领悟的道，就是道自己，道不是简单的1234，世界也不是这1234的推演。他们无法把感悟到的多维的知识转为线性的一维文字表达。既然世界自己就是一本书，我们也无法用一本书（一本小小的书自己也是世界的一部分）来描述整个世界。知识变为书的那一刻起，就是谬论的开始。对话时有上下文，参与对话的人之间误差是最小的。到了书本，上下文的误差就扩大了，知识的偏离也就更大了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们理解的规律，科学，要么有适用的条件，要么是对真实的近似。世界没有必要按照1234的方式去定义，逻辑学自身也未必可靠。按照测不准原理，我们也无法通过实验的方法，探知世界的本源。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;唯心，唯物，形而上，形而下，在某些条件下都是对的，要不然当时也形成不了学派和相信的人。犹如盲人摸象，大家只看到了问题的一面而已，然后坚信世界可以用这个理论去套。一切皆阴阳，万物分五行，万事有因果。越套越离谱，谁都说服不了谁。既然世上没有相同的两片树叶，哪来的普遍规律呢？各种学派，思想都是平等的，谁也不比谁高贵，比谁精确（相对论比牛顿力学精确？你用相对论去测量桌子的长度，更精确吗？测量值存在于人的认识中，但真实值真实存在吗？）。我们不妨多一些包容，在处理问题时不妨多学习一些“敌对”观点，在合适的场景，运用合适的方法。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Type Switch and nil in Go</title>
      <link>http://sample.com/default/Type-Switch-and-nil-in-Go/</link>
      <pubDate>2017-01-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Handle &lt;code&gt;nil&lt;/code&gt; in type switch&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;In Go type switch supports &lt;code&gt;nil&lt;/code&gt; case:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;switch e := err.(type) {&#xA;  case nil:&#xA;    // no error happened&#xA;  case MyError:&#xA;    // Handle MyError type&#xA;  default:&#xA;    // Handle other type of errors&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;Anti-pattern&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; case statement saves an &lt;code&gt;if&lt;/code&gt; statement, but sometimes add &lt;code&gt;if&lt;/code&gt; statement is more clear:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if err == nil {&#xA;  // no error happened, happy to return&#xA;  return&#xA;}&#xA;&#xA;// Now handle errors&#xA;switch e := err.(type) {&#xA;  case MyError:&#xA;    // Handle MyError type&#xA;  default:&#xA;    // Handle other type of errors&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; and not nil is a big difference, use a dedicate &lt;code&gt;if&lt;/code&gt; statement makes it more clear.&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Conclusion&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;If nil handling has a very big meaning, not parallel to other &lt;code&gt;case&lt;/code&gt; statement, it is better use a dedicate &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Open Close Loop</title>
      <link>http://sample.com/default/Open-Close-Loop/</link>
      <pubDate>2016-11-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;开环闭环与组织机构&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;我有一些控制系统开发的经验，不自觉的用控制系统的角度来思考组织机构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;组织是因为一个特定的目的创建的。只要是多人合作的工作就需要组织。控制系统也一样：为了特定的目的，简单的如调节温度，复杂的如大型自动化工厂，需要把硬件设备组织在一起。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;控制系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;控制系统设计，一个非常重要的考虑因素是，开环还是闭环？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所谓开环，就是完全不理会反馈，按照既定计划执行。很多机械化的装置都属于这种。以多米诺骨牌为例，多米诺骨牌的目的：建立一个系统，使远端的骨牌倒下。多米诺的解决方式是推倒第一块，依次推倒下一块，直到最后一块倒下，问题解决。在执行过程中（倒下过程中），完全不考虑意外因素，骨牌高度，距离，地势，甚至风力。出现一次意外，只有失败。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所谓开环，是在执行过程中，监视执行情况，对变化采取应对措施。比如空调，温度高了启动压缩机，低了关闭压缩机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;开环的好处显而易见，系统更柔性，失败率更低。实际的控制系统中多多少少都会引入一些反馈，引入反馈越多不越好吗？这个问题像何不食肉糜一样可笑。不是因为不想而是因为不可得。我总结影响反馈的主要是两个因素：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;误差。从反馈系统得到的信息，和真实情况不是百分百一样的。如果误差过大，以错误值做调整依据，只会更乱。&lt;/li&gt;&#xA;&lt;li&gt;时效性。时效性分为两方面：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;获取信息并传递到控制机构的时间。如果传递速度太慢，或者目标对象变化太快，得到的是历史数据，不能反应当前情况。&lt;/li&gt;&#xA;&lt;li&gt;执行速度和力度。执行机构动作迟缓，或者力度不够，等执行效果起作用，目标对象早已发生变化。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;错误的引入反馈，常见的现象就是震荡，严重时震荡逐渐放大，系统崩溃。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;组织机构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;开环，闭环对应在组织机构里是专治和民主。为什么要开环，不采用闭环？其原因也和控制系统类似：反馈的误差和时效。要达到有效的民主，必须建立高效，低误差的反馈渠道，和高效率的执行机构，否则就陷入混乱。这同时需要软件（人）和硬件（科技）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人类历史无疑是专治占据主要时间，因为技术的不成熟。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;没有有效的保存信息的手段，文字，手绘无法准确表达真实情况。直到照相，录音，摄像等设备的发明。所谓一图胜万言。文学作品想象空间巨大，其实说得是误差巨大。&lt;/li&gt;&#xA;&lt;li&gt;没有高效的信息传递手段，烽火台速度尚可，但带宽不够，无法传递大量信息（其实只能有效传递是否两种状态）。驿站和快马数据量够了但速度太慢。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在这种情况下，能够成功运转的组织，只有专治一途。古希腊是罕见的按照民主方式成功运转的，因为古希腊是城邦国家，组织的规模不大，地域不广，信息的采集和反馈执行都不是瓶颈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与专治相配合，产生了相应的文化。我认为这类文化的特点是：重执行，轻思考；重精神，轻物质。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在无法及时或有效的处理反馈的情况下，最成功的方法是严格按照计划执行。二战时日本在太平洋战场上，面对美军的优势火力，仍然一次次的冲锋。这种愚蠢的行为，是他们重执行，轻反馈的体现。他们无法应对变化，是因为他们的系统是建立在僵化和执行的基础上。高层决定目标，智囊制定计划，大众全力执行。完美的开环设计，智囊不能质疑高层的决定，不可为而为之，大众只管执行，无法获得足够的信息。培养人们的思考意识，信息平等会给整个体系带来干扰，危及社会架构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们可以观察，如果一个企业过多的强调执行力，多半是专治的僵化的，无法适应市场变化的，依赖一时的高利润，垄断，社会绑架而存在的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个企业通过垄断，固化市场，通过控制环境来消除干扰（变化），实现有效的开环控制。但这种僵化的结构，柔性不足，在应对变化前缺乏弹性。容易如生铁般瞬间折断。中国历史，也就是朝代更替的历史。历朝历代都努力通过社会僵化的方法来努力延续，但社会变化的速度最终会超过维持僵化的努力，断裂不可避免。企业也是一样，人事震荡，甚至一夜倒闭都时有耳闻。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Oral vs Written</title>
      <link>http://sample.com/default/Oral-vs-Written/</link>
      <pubDate>2016-11-13 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;口头语与书面语&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;写文章和说话有很多不同，我体会到的有几方面，分别说一说。写和说都不是我的特长，只是说说我的体会罢了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;冗余&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这个区别是媒介导致的，口头语是语音，书面语是纸张。语音在传输上不大可靠，说话者的口齿是否清楚，方言俚语，听者的听力，理解能力，传输距离都是不利因素。一如通讯技术中的解决方法，加入冗余，降低信息密度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语往往啰嗦，目的是增加冗余。听者个别字词没有听清，不影响意思的表达。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语往往增加无意义的字词，“这个”，“那个”，“嗯啊”，目的是降低对听者大脑处理速度的要求。讲课，新闻等复杂的内容，对听者理解力的要求很高，降低语速和插入无意义的字词是非常必要的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;书面语正相反，有了可靠的媒介，冗余不需要的。要求写作时避免重复。增一分则胖，减一分则瘦。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阅读也速度要求，没有冗余，增高的信息密度，不会给阅读带来困难。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;上下文&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;上下文对意思的理解非常重要。表达意思的不是文字和语言，是建立在共同的理解上的。如果给没有笑的功能的外星人看“笑”字，他是无法理解的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;人人都能理解的，首先是五感，触觉，味觉，视觉，听觉，体感。我们用“甜蜜”表示很多非食物的东西，因为我们都能理解“甜蜜”是什么。其次是血缘关系，父母，兄弟，子孙。我们常常把受尊敬的人和物比作母亲，把平等的人比作兄弟等。再把血缘关系映射到社会结构，“家” - &amp;ldquo;国&amp;rdquo;；“父” - “君”；“子” - “臣”。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;既然”甜蜜“可以指食物，也可以指关系，那么如何才能不混淆呢？这就需要上下文。如果话题是食物，自然是食物，话题是爱人，自然是人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;口头语上下文的建立是自然的，常常不是通过语言。餐桌上，瀑布边，会议室，对话对象，都能自然的创建双方的上下文。如果听者不集中注意力，没有建立好上下文，就难以理解对话，把“撒谎“听成”上床“。或者没有共同的经历，也不容易建立上下文。秀才遇见兵，有理说不清。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;书面语要建立上下文，困难多，它的手段只有文字，偶尔借助图片。我们常常看到新闻，小说，以图片开头，也是这个道理。引子，序的作用也是如此。抛出一个问题，电影开头搞一个爆炸，说书艺人的开场白都是这个目的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为上下文的薄弱，用词准确对书面语有了更高的要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;阅读，已经从卖方市场变为买方市场。论语不用在乎读者，读懂论语是读者的责任。而如今，如何让文章让人更容易理解变得更重要。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;叙述主体&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这个问题在口头语中是不存在的，几乎都是“我”。所以不用强调，听者听着也自然。但在书面语上，这是个复杂的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在开始阅读前，叙述主体对读者来说是未知的。读者需要一个识别的过程。写作者需要选择一个适合读者理解的叙述主体，帮助读者建立叙述主体，并坚持始终。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Life Package</title>
      <link>http://sample.com/default/Life-Package/</link>
      <pubDate>2016-11-06 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Life golang package&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Life 是一个 Go 语言的 包(Package) 管理库：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Package 按照依赖顺序启动&lt;/li&gt;&#xA;&lt;li&gt;按照依赖的反序停止&lt;/li&gt;&#xA;&lt;li&gt;钩子函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;详细说明请看：&lt;a href=&#34;http://github.com/redforks/life&#34;&gt;http://github.com/redforks/life&lt;/a&gt; 的 README.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Spriter - 自动生成 css sprite</title>
      <link>http://sample.com/default/Spriter---%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90-css-sprite/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;又一个css sprite工具？是的，她存在的理由是&lt;strong&gt;自动&lt;/strong&gt;。以一个例子来说明，假如有如下css：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(&#39;grp1.object.png&#39;);&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(&#39;grp1.method.png&#39;);&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(&#39;grp1.form.png&#39;);&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(&#39;grp2.list.png&#39;);&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(&#39;grp2.template.png&#39;);&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(&#39;grp2.enum.png&#39;);&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(&#39;grp2.service.png&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;每一个图标，都是单独的图标文件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.object.png&#34; alt=&#34;object&#34; /&gt;:  grp1.object.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.method.png&#34; alt=&#34;method&#34; /&gt;:  grp1.method.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.form.png&#34; alt=&#34;form&#34; /&gt;: grp1.form.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.list.png&#34; alt=&#34;list&#34; /&gt;:  grp2.list.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.template.png&#34; alt=&#34;template&#34; /&gt;:  grp2.template.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.enum.png&#34; alt=&#34;enum&#34; /&gt;: grp2.enum.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.service.png&#34; alt=&#34;service&#34; /&gt;: grp2.service.png&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;运行&lt;code&gt;Spriter&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;spriter -i tree.css -o build/tree.css&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成三个文件：&lt;code&gt;tree.css&lt;/code&gt;, &lt;code&gt;Q-EoXMh-.png&lt;/code&gt;, &lt;code&gt;GyO8rqsS.png&lt;/code&gt;。tree.css的内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(Q-EoXMh-.png) no-repeat;&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(Q-EoXMh-.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(Q-EoXMh-.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(GyO8rqsS.png) no-repeat;&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(GyO8rqsS.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(GyO8rqsS.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(GyO8rqsS.png) no-repeat -48px 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q-EoXMh-.png: &lt;img src=&#34;/assets/media/Q-EoXMh-.png&#34; alt=&#34;Compiled spriter 1&#34; /&gt;, GyO8rqsS.png: &lt;img src=&#34;/assets/media/GyO8rqsS.png&#34; alt=&#34;Compiled spriter 2&#34; /&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 寻找 background 图片，如果符合 &lt;code&gt;group.name.png&lt;/code&gt;格式，按&lt;code&gt;group&lt;/code&gt;名来分组，每组生成一个 sprite ，如这里的 &lt;code&gt;grp1&lt;/code&gt; 和 &lt;code&gt;grp2&lt;/code&gt; 两组。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对生成的 sprite 图片文件，计算 hash value, 用其前缀作为文件名。sprite 任何变化文件名也会相应改变&lt;a name=&#34;footnote1&#34;&gt;¹&lt;/a&gt;。当增加或减少了同组文件的数量，或者修改了图片，则 sprite 文件名也会改变。对 sprite 文件可以安全的打开 http cache，并设置有效期为一万年（开个玩笑，习惯上设置为一年）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件名使用 &lt;code&gt;URL&lt;/code&gt; 安全的 &lt;code&gt;base64&lt;/code&gt; 编码，普通的 &lt;code&gt;base64&lt;/code&gt; 符号集有时会制造麻烦，毕竟图片文件也是用 http URL访问的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt; 语言，最简单的安装方式是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/redforks/css/cmd/spriter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 和 &lt;code&gt;OS/X&lt;/code&gt; 中都能正常运行，理论上 &lt;code&gt;Windows&lt;/code&gt; 也可以，不过没有试过。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;总结&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;优势和特点&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无须手工制作 sprite 文件&lt;/li&gt;&#xA;&lt;li&gt;无须手工维护 sprite image 的 位移 offset&lt;/li&gt;&#xA;&lt;li&gt;开发过程中，直接使用源图片，不要担心 sprite&lt;/li&gt;&#xA;&lt;li&gt;配合 &lt;code&gt;css&lt;/code&gt; 编译工具，把多个 css 文件合并后，运行 &lt;code&gt;Spriter&lt;/code&gt;，保证 sprite 里只有被使用的图像，没有任何带宽浪费。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;任何问题， fire issue at &lt;a href=&#34;http://github.com/redforks/css&#34;&gt;http://github.com/redforks/css&lt;/a&gt; or email: &lt;a href=&#34;mailto:redforks@gmail.com&#34;&gt;redforks@gmail.com&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;#footnote1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 理论上存在着两个不同的文件，拥有相同的 hash value，特别是这里只使用了 hash value 的前缀。但实际上几乎几乎不会发生。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>名字生成器</title>
      <link>http://sample.com/default/%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;软件，特别是企业软件在测试，演示时，需要填充大量的数据。如果使用人工输入，显然效率太低，而机器生成随机字符串，又效果欠佳。这就是名字生成器的作用：生成&lt;strong&gt;随机的看上去有意义&lt;/strong&gt;的名字。目前支持四种名字：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/name?n=100&#34;&gt;人名&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/product?n=100&#34;&gt;产品&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/firm?n=100&#34;&gt;公司&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/address?n=100&#34;&gt;地址&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每一个生成器以原始样本为素材，生成随机的名字。原始样本的数量：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;生成器&lt;/th&gt;&#xA;&lt;th&gt;原始样本数量&lt;sub&gt;(写这篇博文时)&lt;/sub&gt;&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;人名&lt;/td&gt;&#xA;&lt;td&gt;12715&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;产品&lt;/td&gt;&#xA;&lt;td&gt;473347&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;公司&lt;/td&gt;&#xA;&lt;td&gt;32893&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;地址&lt;/td&gt;&#xA;&lt;td&gt;31029&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;生成器接受&lt;strong&gt;n&lt;/strong&gt;参数，控制生成的名字数量。比如：&lt;a href=&#34;http://127.0.0.1:8080/names/address?n=10&#34;&gt;http://127.0.0.1:8080/names/address?n=10&lt;/a&gt;生成10个地址。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;返回纯文本，utf8编码，名字间用回车分隔。非常方便机器调用，各种编程语言都很容易访问。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;相关技术&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;马可夫链(Markov chain)&lt;/li&gt;&#xA;&lt;li&gt;正态分布&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/redforks/math/blob/master/random/weighted_choice.go&#34;&gt;Weighted random choice&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;golang&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>