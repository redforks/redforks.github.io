<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>Forks 的代码工坊</title>
    <link>http://sample.com</link>
    <pubDate>06 Nov 16 09:46 CST</pubDate>
    <item>
      <title>Life Package</title>
      <link>http://sample.com/default/Life-Package/</link>
      <pubDate>2016-11-06 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;Life golang package&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Life 是一个 Go 语言的 包(Package) 管理库：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Package 按照依赖顺序启动&lt;/li&gt;&#xA;&lt;li&gt;按照依赖的反序停止&lt;/li&gt;&#xA;&lt;li&gt;钩子函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;详细说明请看：&lt;a href=&#34;http://github.com/redforks/life&#34;&gt;http://github.com/redforks/life&lt;/a&gt; 的 README.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Spriter - 自动生成 css sprite</title>
      <link>http://sample.com/default/Spriter---%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90-css-sprite/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;又一个css sprite工具？是的，她存在的理由是&lt;strong&gt;自动&lt;/strong&gt;。以一个例子来说明，假如有如下css：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(&#39;grp1.object.png&#39;);&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(&#39;grp1.method.png&#39;);&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(&#39;grp1.form.png&#39;);&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(&#39;grp2.list.png&#39;);&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(&#39;grp2.template.png&#39;);&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(&#39;grp2.enum.png&#39;);&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(&#39;grp2.service.png&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;每一个图标，都是单独的图标文件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.object.png&#34; alt=&#34;object&#34; /&gt;:  grp1.object.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.method.png&#34; alt=&#34;method&#34; /&gt;:  grp1.method.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp1.form.png&#34; alt=&#34;form&#34; /&gt;: grp1.form.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.list.png&#34; alt=&#34;list&#34; /&gt;:  grp2.list.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.template.png&#34; alt=&#34;template&#34; /&gt;:  grp2.template.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.enum.png&#34; alt=&#34;enum&#34; /&gt;: grp2.enum.png&lt;/li&gt;&#xA;&lt;li&gt;&lt;img src=&#34;/assets/media/grp2.service.png&#34; alt=&#34;service&#34; /&gt;: grp2.service.png&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;运行&lt;code&gt;Spriter&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;spriter -i tree.css -o build/tree.css&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成三个文件：&lt;code&gt;tree.css&lt;/code&gt;, &lt;code&gt;Q-EoXMh-.png&lt;/code&gt;, &lt;code&gt;GyO8rqsS.png&lt;/code&gt;。tree.css的内容:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;.icon_object {&#xA;  background: url(Q-EoXMh-.png) no-repeat;&#xA;}&#xA;&#xA;.icon_method {&#xA;  background: url(Q-EoXMh-.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_form {&#xA;  background: url(Q-EoXMh-.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_list {&#xA;  background: url(GyO8rqsS.png) no-repeat;&#xA;}&#xA;&#xA;.icon_template {&#xA;  background: url(GyO8rqsS.png) no-repeat -16px 0;&#xA;}&#xA;&#xA;.icon_enum {&#xA;  background: url(GyO8rqsS.png) no-repeat -32px 0;&#xA;}&#xA;&#xA;.icon_service {&#xA;  background: url(GyO8rqsS.png) no-repeat -48px 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Q-EoXMh-.png: &lt;img src=&#34;/assets/media/Q-EoXMh-.png&#34; alt=&#34;Compiled spriter 1&#34; /&gt;, GyO8rqsS.png: &lt;img src=&#34;/assets/media/GyO8rqsS.png&#34; alt=&#34;Compiled spriter 2&#34; /&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 寻找 background 图片，如果符合 &lt;code&gt;group.name.png&lt;/code&gt;格式，按&lt;code&gt;group&lt;/code&gt;名来分组，每组生成一个 sprite ，如这里的 &lt;code&gt;grp1&lt;/code&gt; 和 &lt;code&gt;grp2&lt;/code&gt; 两组。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对生成的 sprite 图片文件，计算 hash value, 用其前缀作为文件名。sprite 任何变化文件名也会相应改变&lt;a name=&#34;footnote1&#34;&gt;¹&lt;/a&gt;。当增加或减少了同组文件的数量，或者修改了图片，则 sprite 文件名也会改变。对 sprite 文件可以安全的打开 http cache，并设置有效期为一万年（开个玩笑，习惯上设置为一年）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;文件名使用 &lt;code&gt;URL&lt;/code&gt; 安全的 &lt;code&gt;base64&lt;/code&gt; 编码，普通的 &lt;code&gt;base64&lt;/code&gt; 符号集有时会制造麻烦，毕竟图片文件也是用 http URL访问的。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Spriter&lt;/code&gt; 使用 &lt;code&gt;Go&lt;/code&gt; 语言，最简单的安装方式是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/redforks/css/cmd/spriter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 和 &lt;code&gt;OS/X&lt;/code&gt; 中都能正常运行，理论上 &lt;code&gt;Windows&lt;/code&gt; 也可以，不过没有试过。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;总结&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;优势和特点&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;无须手工制作 sprite 文件&lt;/li&gt;&#xA;&lt;li&gt;无须手工维护 sprite image 的 位移 offset&lt;/li&gt;&#xA;&lt;li&gt;开发过程中，直接使用源图片，不要担心 sprite&lt;/li&gt;&#xA;&lt;li&gt;配合 &lt;code&gt;css&lt;/code&gt; 编译工具，把多个 css 文件合并后，运行 &lt;code&gt;Spriter&lt;/code&gt;，保证 sprite 里只有被使用的图像，没有任何带宽浪费。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;任何问题， fire issue at &lt;a href=&#34;http://github.com/redforks/css&#34;&gt;http://github.com/redforks/css&lt;/a&gt; or email: &lt;a href=&#34;mailto:redforks@gmail.com&#34;&gt;redforks@gmail.com&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;sup&gt;&lt;a href=&#34;#footnote1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; 理论上存在着两个不同的文件，拥有相同的 hash value，特别是这里只使用了 hash value 的前缀。但实际上几乎几乎不会发生。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>名字生成器</title>
      <link>http://sample.com/default/%E5%90%8D%E5%AD%97%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>2016-10-31 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;软件，特别是企业软件在测试，演示时，需要填充大量的数据。如果使用人工输入，显然效率太低，而机器生成随机字符串，又效果欠佳。这就是名字生成器的作用：生成&lt;strong&gt;随机的看上去有意义&lt;/strong&gt;的名字。目前支持四种名字：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/name?n=100&#34;&gt;人名&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/product?n=100&#34;&gt;产品&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/firm?n=100&#34;&gt;公司&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;/names/address?n=100&#34;&gt;地址&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;每一个生成器以原始样本为素材，生成随机的名字。原始样本的数量：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;生成器&lt;/th&gt;&#xA;&lt;th&gt;原始样本数量&lt;sub&gt;(写这篇博文时)&lt;/sub&gt;&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;人名&lt;/td&gt;&#xA;&lt;td&gt;12715&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;产品&lt;/td&gt;&#xA;&lt;td&gt;473347&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;公司&lt;/td&gt;&#xA;&lt;td&gt;32893&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;地址&lt;/td&gt;&#xA;&lt;td&gt;31029&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;生成器接受&lt;strong&gt;n&lt;/strong&gt;参数，控制生成的名字数量。比如：&lt;a href=&#34;http://127.0.0.1:8080/names/address?n=10&#34;&gt;http://127.0.0.1:8080/names/address?n=10&lt;/a&gt;生成10个地址。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;返回纯文本，utf8编码，名字间用回车分隔。非常方便机器调用，各种编程语言都很容易访问。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;相关技术&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;马可夫链(Markov chain)&lt;/li&gt;&#xA;&lt;li&gt;正态分布&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/redforks/math/blob/master/random/weighted_choice.go&#34;&gt;Weighted random choice&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;golang&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>